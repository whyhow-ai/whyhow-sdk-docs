{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the WhyHow Knowledge Graph Studio SDK Documentation","text":"<p>The WhyHow Knowledge Graph Studio SDK enables you to quickly and easily build automated knowledge graphs tailored to your unique worldview. Instantly build, extend, and query well-scoped KGs using a raw PDF or CSV and simple seed concepts in natural language.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Flexible Data Ingestion &amp; Framework integration: Plug your existing structured and unstructured data pre-processing pipelines into our graph creation process and Graph Studio</p> </li> <li> <p>Flexible Querying Logic &amp; Answer Construction: Build on top of our Graph Querying Engine to enhance and customize the information coming from the graph</p> </li> <li> <p>Flexible Multi Graph&lt;&gt;Agentic Workflows: Build multi-graph multi-agent workflows with modular WhyHow graphs</p> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install the package by following the Installation Guide</li> <li>Initialize the SDK client with your WhyHow API key</li> <li>Create a workspace and add raw documents using <code>client.documents.upload()</code></li> <li>Create a graph for the workspace using <code>client.graphs.create()</code> using a list of seed concepts</li> <li>Query the graph with natural language using <code>client.graphs.query_unstructured()</code></li> </ol> <p>For a detailed walkthrough and code examples, check out the Tutorial.</p>"},{"location":"api/","title":"API Reference","text":"<p>This document provides a reference for the WhyHow API.</p> <p>All synchronous functions in WhyHow API have corresponding asynchronous counterparts. WhyHow client is essentially a thin wrapper around httpx, which provides flexibility for customization. Users should close the client when it's no longer needed, as outlined in the httpx documentation.</p>"},{"location":"api/#whyhow.client","title":"client","text":"<p>Implementation of the client logic.</p>"},{"location":"api/#whyhow.client.AsyncWhyHow","title":"AsyncWhyHow","text":"<pre><code>AsyncWhyHow(api_key: str | None = None, base_url: str | None = None, httpx_kwargs: dict[str, Any] | None = None)\n</code></pre> <p>Asynchronous client for the WhyHow API.</p> <p>Parameters:</p> <ul> <li> <code>api_key</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The API key to use for authentication. If not provided, the WHYHOW_API_KEY environment variable will be used.</p> </li> <li> <code>base_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base URL for the API.</p> </li> <li> <code>httpx_kwargs</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the httpx async client.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>httpx_client</code>               (<code>AsyncClient</code>)           \u2013            <p>An async httpx client.</p> </li> </ul>"},{"location":"api/#whyhow.client.AsyncWhyHow.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the async client.</p>"},{"location":"api/#whyhow.client.WhyHow","title":"WhyHow","text":"<pre><code>WhyHow(api_key: str | None = None, base_url: str | None = None, httpx_kwargs: dict[str, Any] | None = None)\n</code></pre> <p>Synchronous client for the WhyHow API.</p> <p>Parameters:</p> <ul> <li> <code>api_key</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The API key to use for authentication. If not provided, the WHYHOW_API_KEY environment variable will be used.</p> </li> <li> <code>base_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base URL for the API.</p> </li> <li> <code>httpx_kwargs</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the httpx client.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>httpx_client</code>               (<code>Client</code>)           \u2013            <p>A synchronous httpx client.</p> </li> </ul>"},{"location":"api/#whyhow.client.WhyHow.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the client.</p>"},{"location":"api/#whyhow.resources","title":"resources","text":"<p>Collection of route specific resources.</p>"},{"location":"api/#whyhow.resources.AsyncChunksResource","title":"AsyncChunksResource","text":"<p>               Bases: <code>AsyncResource</code></p> <p>Chunk resource.</p>"},{"location":"api/#whyhow.resources.AsyncChunksResource.create","title":"create  <code>async</code>","text":"<pre><code>create(workspace_id: str, chunks: list[Chunk]) -&gt; list[Chunk]\n</code></pre> <p>Add chunks to a workspace.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>chunks</code>               (<code>list[Chunk]</code>)           \u2013            <p>The chunks to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Chunk]</code>           \u2013            <p>The updated chunks.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncChunksResource.get","title":"get  <code>async</code>","text":"<pre><code>get(chunk_id: str, include_embeddings: bool | None = None) -&gt; Chunk\n</code></pre> <p>Get chunk by ID.</p> <p>Parameters:</p> <ul> <li> <code>chunk_id</code>               (<code>str</code>)           \u2013            <p>The ID of the chunk.</p> </li> <li> <code>include_embeddings</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether to include embeddings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chunk</code>           \u2013            <p>The chunk.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncChunksResource.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(limit: int = 10, workspace_id: str | None = None, workspace_name: str | None = None, document_id: str | None = None, document_filename: str | None = None, include_embeddings: bool | None = None) -&gt; AsyncIterator[Chunk]\n</code></pre> <p>Get all chunks.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of chunks to return.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the workspace.</p> </li> <li> <code>document_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the document.</p> </li> <li> <code>document_filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename of the document.</p> </li> <li> <code>include_embeddings</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether to include embeddings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[Chunk]</code>           \u2013            <p>The chunk iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Chunk</code>           \u2013            <p>The chunk.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncDocumentsResource","title":"AsyncDocumentsResource","text":"<p>               Bases: <code>AsyncResource</code></p> <p>Async documents resource.</p>"},{"location":"api/#whyhow.resources.AsyncDocumentsResource.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(document_id: str) -&gt; Document\n</code></pre> <p>Delete a document.</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>The document ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the document is deleted but not returned.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncDocumentsResource.get","title":"get  <code>async</code>","text":"<pre><code>get(document_id: str) -&gt; Document\n</code></pre> <p>Get documents.</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>The document ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncDocumentsResource.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(limit: int = 10, filename: str | None = None, workspace_id: str | None = None, workspace_name: str | None = None) -&gt; AsyncIterator[Document]\n</code></pre> <p>Get all documents.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of documents to return.</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace ID.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[Document]</code>           \u2013            <p>The document iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncDocumentsResource.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(path: str | Path, workspace_id: str, max_seconds: int = 60, sleep_seconds: float = 1.5) -&gt; Document\n</code></pre> <p>Upload a document.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The path to the document.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>max_seconds</code>               (<code>int</code>, default:                   <code>60</code> )           \u2013            <p>The maximum number of seconds to wait for the document to be uploaded/processed.</p> </li> <li> <code>sleep_seconds</code>               (<code>float</code>, default:                   <code>1.5</code> )           \u2013            <p>The number of seconds to sleep between polling.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the file is not found.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the file format is not supported or the upload failed.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource","title":"AsyncGraphsResource","text":"<p>               Bases: <code>AsyncResource</code></p> <p>Graph resources.</p>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.add_chunks","title":"add_chunks  <code>async</code>","text":"<pre><code>add_chunks(graph_id: str, document_ids: list[str] | None = None, data_types: list[VALID_DATA_TYPE] | None = None, tags: list[str] | None = None, user_metadata: dict[str, Any] | None = None, ids: list[str] | None = None) -&gt; Graph\n</code></pre> <p>Add chunks to a graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>document_ids</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the documents.</p> </li> <li> <code>data_types</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The data types. Possible values are \"string\" and \"object\".</p> </li> <li> <code>tags</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The tags.</p> </li> <li> <code>user_metadata</code>               (<code>dict[str, Any]</code>, default:                   <code>None</code> )           \u2013            <p>The user metadata.</p> </li> <li> <code>ids</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the chunks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.add_triples","title":"add_triples  <code>async</code>","text":"<pre><code>add_triples(graph_id: str, triples: list[Triple], strict_mode: bool = False) -&gt; Graph\n</code></pre> <p>Add triples to a graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>triples</code>               (<code>list[Triple]</code>)           \u2013            <p>The triples.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.create","title":"create  <code>async</code>","text":"<pre><code>create(name: str, workspace_id: str, schema_id: str, mode: CREATION_MODE = 'unstructured', document_ids: list[str] | None = None) -&gt; Graph\n</code></pre> <p>Create a graph.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>schema_id</code>               (<code>str</code>)           \u2013            <p>The ID of the schema.</p> </li> <li> <code>mode</code>               (<code>Literal['unstructured', 'structured', 'mixed']</code>, default:                   <code>'unstructured'</code> )           \u2013            <p>The creation mode.</p> </li> <li> <code>document_ids</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the documents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.create_graph_from_graph_chunks","title":"create_graph_from_graph_chunks  <code>async</code>","text":"<pre><code>create_graph_from_graph_chunks(name: str, workspace_id: str, graph_chunks: list[GraphChunk]) -&gt; Graph\n</code></pre> <p>Create a graph from graph chunks.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>graph_chunks</code>               (<code>list[GraphChunk]</code>)           \u2013            <p>The graph chunks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.create_graph_from_triples","title":"create_graph_from_triples  <code>async</code>","text":"<pre><code>create_graph_from_triples(name: str, workspace_id: str, triples: list[Triple], schema_id: str | None = None) -&gt; Graph\n</code></pre> <p>Create a graph from triples.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>triples</code>               (<code>list[Triple]</code>)           \u2013            <p>The triples.</p> </li> <li> <code>schema_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the schema. If not provided, the schema will be inferred.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.export_cypher","title":"export_cypher  <code>async</code>","text":"<pre><code>export_cypher(graph_id: str) -&gt; str\n</code></pre> <p>Export a graph to Cypher.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The Cypher text.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.get","title":"get  <code>async</code>","text":"<pre><code>get(graph_id: str) -&gt; Graph\n</code></pre> <p>Get a graph by its ID.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(limit: int = 10, name: str | None = None, workspace_id: str | None = None, workspace_name: str | None = None, schema_id: str | None = None, schema_name: str | None = None) -&gt; AsyncIterator[Graph]\n</code></pre> <p>Get all graphs.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of graphs to return.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the workspace.</p> </li> <li> <code>schema_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the schema.</p> </li> <li> <code>schema_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[Graph]</code>           \u2013            <p>The graph iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.get_all_triples","title":"get_all_triples  <code>async</code>","text":"<pre><code>get_all_triples(graph_id: str, limit: int = 10) -&gt; AsyncIterator[Triple]\n</code></pre> <p>Get all triples.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of triples to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[Triple]</code>           \u2013            <p>The triple iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Triple</code>           \u2013            <p>The triple.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.query_structured","title":"query_structured  <code>async</code>","text":"<pre><code>query_structured(graph_id: str, entities: list[str] | None = None, relations: list[str] | None = None, values: list[str] | None = None) -&gt; Query\n</code></pre> <p>Structured query.</p>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.query_unstructured","title":"query_unstructured  <code>async</code>","text":"<pre><code>query_unstructured(graph_id: str, query: str, return_answer: bool = True, include_chunks: bool = False) -&gt; Query\n</code></pre> <p>Query an unstructured graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>The query.</p> </li> <li> <code>return_answer</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the answer.</p> </li> <li> <code>include_chunks</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include chunks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>The query.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no queries are found in the response body.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncGraphsResource.update","title":"update  <code>async</code>","text":"<pre><code>update(graph_id: str, name: str | None = None, public: bool | None = None) -&gt; Graph\n</code></pre> <p>Update a graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the graph.</p> </li> <li> <code>public</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the graph is public.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncSchemasResource","title":"AsyncSchemasResource","text":"<p>               Bases: <code>AsyncResource</code></p> <p>Async schemas resource.</p>"},{"location":"api/#whyhow.resources.AsyncSchemasResource.create","title":"create  <code>async</code>","text":"<pre><code>create(name: str, workspace_id: str, entities: list[SchemaEntity], relations: list[SchemaRelation], patterns: list[SchemaTriplePattern]) -&gt; Schema\n</code></pre> <p>Create a schema.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The schema name.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>entities</code>               (<code>list[SchemaEntity]</code>)           \u2013            <p>The schema entities.</p> </li> <li> <code>relations</code>               (<code>list[SchemaRelation]</code>)           \u2013            <p>The schema relations.</p> </li> <li> <code>patterns</code>               (<code>list[TriplePattern]</code>)           \u2013            <p>The schema patterns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema</code>           \u2013            <p>The schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncSchemasResource.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(schema_id: str) -&gt; Schema\n</code></pre> <p>Delete a schema.</p> <p>Parameters:</p> <ul> <li> <code>schema_id</code>               (<code>str</code>)           \u2013            <p>The schema ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema</code>           \u2013            <p>The schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncSchemasResource.generate","title":"generate  <code>async</code>","text":"<pre><code>generate(questions: list[str]) -&gt; tuple[list[SchemaEntity], list[SchemaRelation], list[SchemaTriplePattern]]\n</code></pre> <p>Generate a schema.</p> <p>Parameters:</p> <ul> <li> <code>questions</code>               (<code>list[str]</code>)           \u2013            <p>The questions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>entities</code> (              <code>list[SchemaEntity]</code> )          \u2013            <p>The schema entities.</p> </li> <li> <code>relations</code> (              <code>list[SchemaRelation]</code> )          \u2013            <p>The schema relations.</p> </li> <li> <code>patterns</code> (              <code>list[SchemaTriplePattern]</code> )          \u2013            <p>The schema patterns.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncSchemasResource.get","title":"get  <code>async</code>","text":"<pre><code>get(schema_id: str) -&gt; Schema\n</code></pre> <p>Get a schema.</p> <p>Parameters:</p> <ul> <li> <code>schema_id</code>               (<code>str</code>)           \u2013            <p>The schema ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema</code>           \u2013            <p>The schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncSchemasResource.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(limit: int = 10, workspace_id: str | None = None, workspace_name: str | None = None) -&gt; AsyncIterator[Schema]\n</code></pre> <p>Get all schemas.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of schemas to fetch in one request.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace ID.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[Schema]</code>           \u2013            <p>The schema iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Schema</code>           \u2013            <p>A schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncSchemasResource.load_json","title":"load_json  <code>staticmethod</code>","text":"<pre><code>load_json(file_path: str | Path) -&gt; tuple[list[SchemaEntity], list[SchemaRelation], list[SchemaTriplePattern]]\n</code></pre> <p>Load a JSON file containing a schema.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str | Path</code>)           \u2013            <p>The file path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[SchemaEntity]</code>           \u2013            <p>The schema entities.</p> </li> <li> <code>list[SchemaRelation]</code>           \u2013            <p>The schema relations.</p> </li> <li> <code>list[SchemaTriplePattern]</code>           \u2013            <p>The schema patterns.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncWorkspacesResource","title":"AsyncWorkspacesResource","text":"<p>               Bases: <code>AsyncResource</code></p> <p>Workspaces resource.</p>"},{"location":"api/#whyhow.resources.AsyncWorkspacesResource.create","title":"create  <code>async</code>","text":"<pre><code>create(name: str) -&gt; Workspace\n</code></pre> <p>Create a workspace.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the workspace.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>The created workspace.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncWorkspacesResource.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(workspace_id: str) -&gt; Workspace\n</code></pre> <p>Delete a workspace.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncWorkspacesResource.get","title":"get  <code>async</code>","text":"<pre><code>get(workspace_id: str) -&gt; Workspace\n</code></pre> <p>Get a workspaces.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>The workspace.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncWorkspacesResource.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(limit: int = 10, name: str | None = None) -&gt; AsyncIterator[Workspace]\n</code></pre> <p>Iterate over all workspaces.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of workspaces to fetch in each request.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the workspace to filter by.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>A workspace.</p> </li> </ul>"},{"location":"api/#whyhow.resources.AsyncWorkspacesResource.update","title":"update  <code>async</code>","text":"<pre><code>update(workspace_id: str, name: str) -&gt; Workspace\n</code></pre> <p>Update a workspace.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The new name for the workspace.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>The updated workspace.</p> </li> </ul>"},{"location":"api/#whyhow.resources.ChunksResource","title":"ChunksResource","text":"<p>               Bases: <code>Resource</code></p> <p>Chunk resource.</p>"},{"location":"api/#whyhow.resources.ChunksResource.create","title":"create","text":"<pre><code>create(workspace_id: str, chunks: list[Chunk]) -&gt; list[Chunk]\n</code></pre> <p>Add chunks to a workspace.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>chunks</code>               (<code>list[Chunk]</code>)           \u2013            <p>The chunks to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Chunk]</code>           \u2013            <p>The updated chunks.</p> </li> </ul>"},{"location":"api/#whyhow.resources.ChunksResource.get","title":"get","text":"<pre><code>get(chunk_id: str, include_embeddings: bool | None = None) -&gt; Chunk\n</code></pre> <p>Get chunk by ID.</p> <p>Parameters:</p> <ul> <li> <code>chunk_id</code>               (<code>str</code>)           \u2013            <p>The ID of the chunk.</p> </li> <li> <code>include_embeddings</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether to include embeddings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chunk</code>           \u2013            <p>The chunk.</p> </li> </ul>"},{"location":"api/#whyhow.resources.ChunksResource.get_all","title":"get_all","text":"<pre><code>get_all(limit: int = 10, workspace_id: str | None = None, workspace_name: str | None = None, document_id: str | None = None, document_filename: str | None = None, include_embeddings: bool | None = None) -&gt; Iterator[Chunk]\n</code></pre> <p>Get all chunks.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of chunks to return.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the workspace.</p> </li> <li> <code>document_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the document.</p> </li> <li> <code>document_filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename of the document.</p> </li> <li> <code>include_embeddings</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether to include embeddings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Chunk]</code>           \u2013            <p>The chunk iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Chunk</code>           \u2013            <p>The chunk.</p> </li> </ul>"},{"location":"api/#whyhow.resources.DocumentsResource","title":"DocumentsResource","text":"<p>               Bases: <code>Resource</code></p> <p>Documents resource.</p>"},{"location":"api/#whyhow.resources.DocumentsResource.delete","title":"delete","text":"<pre><code>delete(document_id: str) -&gt; Document\n</code></pre> <p>Delete a document.</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>The document ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the document is deleted but not returned.</p> </li> </ul>"},{"location":"api/#whyhow.resources.DocumentsResource.get","title":"get","text":"<pre><code>get(document_id: str) -&gt; Document\n</code></pre> <p>Get documents.</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>The document ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul>"},{"location":"api/#whyhow.resources.DocumentsResource.get_all","title":"get_all","text":"<pre><code>get_all(limit: int = 10, filename: str | None = None, workspace_id: str | None = None, workspace_name: str | None = None) -&gt; Iterator[Document]\n</code></pre> <p>Get all documents.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of documents to return.</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace ID.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Document]</code>           \u2013            <p>The document iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul>"},{"location":"api/#whyhow.resources.DocumentsResource.upload","title":"upload","text":"<pre><code>upload(path: str | Path, workspace_id: str, max_seconds: int = 60, sleep_seconds: float = 1.5) -&gt; Document\n</code></pre> <p>Upload a document.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The path to the document.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>max_seconds</code>               (<code>int</code>, default:                   <code>60</code> )           \u2013            <p>The maximum number of seconds to wait for the document to be uploaded/processed.</p> </li> <li> <code>sleep_seconds</code>               (<code>float</code>, default:                   <code>1.5</code> )           \u2013            <p>The number of seconds to sleep between polling.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Document</code>           \u2013            <p>The document.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the file is not found.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the file format is not supported or the upload fails.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource","title":"GraphsResource","text":"<p>               Bases: <code>Resource</code></p> <p>Graph resources.</p>"},{"location":"api/#whyhow.resources.GraphsResource.add_chunks","title":"add_chunks","text":"<pre><code>add_chunks(graph_id: str, document_ids: list[str] | None = None, data_types: list[VALID_DATA_TYPE] | None = None, tags: list[str] | None = None, user_metadata: dict[str, Any] | None = None, ids: list[str] | None = None) -&gt; Graph\n</code></pre> <p>Add chunks to a graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>document_ids</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the documents.</p> </li> <li> <code>data_types</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The data types. Possible values are \"string\" and \"object\".</p> </li> <li> <code>tags</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The tags.</p> </li> <li> <code>user_metadata</code>               (<code>dict[str, Any]</code>, default:                   <code>None</code> )           \u2013            <p>The user metadata.</p> </li> <li> <code>ids</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the chunks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.add_triples","title":"add_triples","text":"<pre><code>add_triples(graph_id: str, triples: list[Triple], strict_mode: bool = False) -&gt; Graph\n</code></pre> <p>Add triples to a graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>triples</code>               (<code>list[Triple]</code>)           \u2013            <p>The triples.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.create","title":"create","text":"<pre><code>create(name: str, workspace_id: str, schema_id: str, mode: CREATION_MODE = 'unstructured', document_ids: list[str] | None = None) -&gt; Graph\n</code></pre> <p>Create a graph.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>schema_id</code>               (<code>str</code>)           \u2013            <p>The ID of the schema.</p> </li> <li> <code>mode</code>               (<code>Literal['unstructured', 'structured', 'mixed']</code>, default:                   <code>'unstructured'</code> )           \u2013            <p>The creation mode.</p> </li> <li> <code>document_ids</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the documents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.create_graph_from_graph_chunks","title":"create_graph_from_graph_chunks","text":"<pre><code>create_graph_from_graph_chunks(name: str, workspace_id: str, graph_chunks: list[GraphChunk]) -&gt; Graph\n</code></pre> <p>Create a graph from graph chunks.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>graph_chunks</code>               (<code>list[GraphChunk]</code>)           \u2013            <p>The graph chunks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.create_graph_from_triples","title":"create_graph_from_triples","text":"<pre><code>create_graph_from_triples(name: str, workspace_id: str, triples: list[Triple], schema_id: str | None = None) -&gt; Graph\n</code></pre> <p>Create a graph from triples.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>triples</code>               (<code>list[Triple]</code>)           \u2013            <p>The triples.</p> </li> <li> <code>schema_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the schema. If not provided, the schema will be inferred.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.export_cypher","title":"export_cypher","text":"<pre><code>export_cypher(graph_id: str) -&gt; str\n</code></pre> <p>Export a graph to Cypher.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The Cypher text.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.get","title":"get","text":"<pre><code>get(graph_id: str) -&gt; Graph\n</code></pre> <p>Get a graph by its ID.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.get_all","title":"get_all","text":"<pre><code>get_all(limit: int = 10, name: str | None = None, workspace_id: str | None = None, workspace_name: str | None = None, schema_id: str | None = None, schema_name: str | None = None) -&gt; Iterator[Graph]\n</code></pre> <p>Get all graphs.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of graphs to return.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the graph.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the workspace.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the workspace.</p> </li> <li> <code>schema_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the schema.</p> </li> <li> <code>schema_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Graph]</code>           \u2013            <p>The graph iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.get_all_triples","title":"get_all_triples","text":"<pre><code>get_all_triples(graph_id: str, limit: int = 10) -&gt; Iterator[Triple]\n</code></pre> <p>Get all triples.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of triples to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Triple]</code>           \u2013            <p>The triple iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Triple</code>           \u2013            <p>The triple.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.query_structured","title":"query_structured","text":"<pre><code>query_structured(graph_id: str, entities: list[str] | None = None, relations: list[str] | None = None, values: list[str] | None = None) -&gt; Query\n</code></pre> <p>Structured query.</p>"},{"location":"api/#whyhow.resources.GraphsResource.query_unstructured","title":"query_unstructured","text":"<pre><code>query_unstructured(graph_id: str, query: str, return_answer: bool = True, include_chunks: bool = False) -&gt; Query\n</code></pre> <p>Unstructured query.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>The query.</p> </li> <li> <code>return_answer</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the answer.</p> </li> <li> <code>include_chunks</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include chunks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>The query.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no queries are found in the response body.</p> </li> </ul>"},{"location":"api/#whyhow.resources.GraphsResource.update","title":"update","text":"<pre><code>update(graph_id: str, name: str | None = None, public: bool | None = None) -&gt; Graph\n</code></pre> <p>Update a graph.</p> <p>Parameters:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The ID of the graph.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the graph.</p> </li> <li> <code>public</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the graph is public.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>The graph.</p> </li> </ul>"},{"location":"api/#whyhow.resources.SchemasResource","title":"SchemasResource","text":"<p>               Bases: <code>Resource</code></p> <p>Schemas resource.</p>"},{"location":"api/#whyhow.resources.SchemasResource.create","title":"create","text":"<pre><code>create(name: str, workspace_id: str, entities: list[SchemaEntity], relations: list[SchemaRelation], patterns: list[SchemaTriplePattern]) -&gt; Schema\n</code></pre> <p>Create a schema.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The schema name.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>entities</code>               (<code>list[SchemaEntity]</code>)           \u2013            <p>The schema entities.</p> </li> <li> <code>relations</code>               (<code>list[SchemaRelation]</code>)           \u2013            <p>The schema relations.</p> </li> <li> <code>patterns</code>               (<code>list[TriplePattern]</code>)           \u2013            <p>The schema patterns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema</code>           \u2013            <p>The schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.SchemasResource.delete","title":"delete","text":"<pre><code>delete(schema_id: str) -&gt; Schema\n</code></pre> <p>Delete a schema.</p> <p>Parameters:</p> <ul> <li> <code>schema_id</code>               (<code>str</code>)           \u2013            <p>The schema ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema</code>           \u2013            <p>The schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.SchemasResource.generate","title":"generate","text":"<pre><code>generate(questions: list[str]) -&gt; tuple[list[SchemaEntity], list[SchemaRelation], list[SchemaTriplePattern]]\n</code></pre> <p>Generate a schema.</p> <p>Parameters:</p> <ul> <li> <code>questions</code>               (<code>list[str]</code>)           \u2013            <p>The questions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>entities</code> (              <code>list[SchemaEntity]</code> )          \u2013            <p>The schema entities.</p> </li> <li> <code>relations</code> (              <code>list[SchemaRelation]</code> )          \u2013            <p>The schema relations.</p> </li> <li> <code>patterns</code> (              <code>list[SchemaTriplePattern]</code> )          \u2013            <p>The schema patterns.</p> </li> </ul>"},{"location":"api/#whyhow.resources.SchemasResource.get","title":"get","text":"<pre><code>get(schema_id: str) -&gt; Schema\n</code></pre> <p>Get a schema.</p> <p>Parameters:</p> <ul> <li> <code>schema_id</code>               (<code>str</code>)           \u2013            <p>The schema ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema</code>           \u2013            <p>The schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.SchemasResource.get_all","title":"get_all","text":"<pre><code>get_all(limit: int = 10, workspace_id: str | None = None, workspace_name: str | None = None) -&gt; Iterator[Schema]\n</code></pre> <p>Get all schemas.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of schemas to fetch in one request.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace ID.</p> </li> <li> <code>workspace_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The workspace name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Schema]</code>           \u2013            <p>The schema iterator.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Schema</code>           \u2013            <p>A schema.</p> </li> </ul>"},{"location":"api/#whyhow.resources.SchemasResource.load_json","title":"load_json  <code>staticmethod</code>","text":"<pre><code>load_json(file_path: str | Path) -&gt; tuple[list[SchemaEntity], list[SchemaRelation], list[SchemaTriplePattern]]\n</code></pre> <p>Load a JSON file containing a schema.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str | Path</code>)           \u2013            <p>The file path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[SchemaEntity]</code>           \u2013            <p>The schema entities.</p> </li> <li> <code>list[SchemaRelation]</code>           \u2013            <p>The schema relations.</p> </li> <li> <code>list[SchemaTriplePattern]</code>           \u2013            <p>The schema patterns.</p> </li> </ul>"},{"location":"api/#whyhow.resources.WorkspacesResource","title":"WorkspacesResource","text":"<p>               Bases: <code>Resource</code></p> <p>Workspaces resource.</p>"},{"location":"api/#whyhow.resources.WorkspacesResource.create","title":"create","text":"<pre><code>create(name: str) -&gt; Workspace\n</code></pre> <p>Create a workspace.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the workspace.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>The created workspace.</p> </li> </ul>"},{"location":"api/#whyhow.resources.WorkspacesResource.delete","title":"delete","text":"<pre><code>delete(workspace_id: str) -&gt; Workspace\n</code></pre> <p>Delete a workspace.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> </ul>"},{"location":"api/#whyhow.resources.WorkspacesResource.get","title":"get","text":"<pre><code>get(workspace_id: str) -&gt; Workspace\n</code></pre> <p>Get a workspaces.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>The workspace.</p> </li> </ul>"},{"location":"api/#whyhow.resources.WorkspacesResource.get_all","title":"get_all","text":"<pre><code>get_all(limit: int = 10, name: str | None = None) -&gt; Iterator[Workspace]\n</code></pre> <p>Iterate over all workspaces.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of workspaces to fetch in each request.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the workspace to filter by.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>A workspace.</p> </li> </ul>"},{"location":"api/#whyhow.resources.WorkspacesResource.update","title":"update","text":"<pre><code>update(workspace_id: str, name: str) -&gt; Workspace\n</code></pre> <p>Update a workspace.</p> <p>Parameters:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The new name for the workspace.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Workspace</code>           \u2013            <p>The updated workspace.</p> </li> </ul>"},{"location":"api/#whyhow.schemas","title":"schemas","text":"<p>User facing pyndantic models.</p>"},{"location":"api/#whyhow.schemas.Chunk","title":"Chunk","text":"<p>               Bases: <code>BaseModel</code></p> <p>Chunk model.</p> <p>Attributes:</p> <ul> <li> <code>chunk_id</code>               (<code>str | None</code>)           \u2013            <p>The chunk ID.</p> </li> <li> <code>created_at</code>               (<code>datetime | None</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>datetime | None</code>)           \u2013            <p>The update datetime.</p> </li> <li> <code>document_id</code>               (<code>str | None</code>)           \u2013            <p>The document ID.</p> </li> <li> <code>workspace_ids</code>               (<code>list[str] | None</code>)           \u2013            <p>The workspace IDs.</p> </li> <li> <code>metadata</code>               (<code>ChunkMetadata | None</code>)           \u2013            <p>The chunk metadata.</p> </li> <li> <code>content</code>               (<code>str | dict[str, Any]</code>)           \u2013            <p>The chunk content.</p> </li> <li> <code>embedding</code>               (<code>list[float] | None</code>)           \u2013            <p>The chunk embedding.</p> </li> <li> <code>tags</code>               (<code>dict[str, list[str]] | list[str]</code>)           \u2013            <p>The chunk tags.</p> </li> <li> <code>user_metadata</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The chunk user metadata.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.ChunkMetadata","title":"ChunkMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Chunk metadata model.</p> <p>Attributes:</p> <ul> <li> <code>language</code>               (<code>(str, optional)</code>)           \u2013            <p>The chunk language.</p> </li> <li> <code>length</code>               (<code>(int, optional)</code>)           \u2013            <p>The chunk length.</p> </li> <li> <code>size</code>               (<code>(int, optional)</code>)           \u2013            <p>The chunk size.</p> </li> <li> <code>data_source_type</code>               (<code>(str, optional)</code>)           \u2013            <p>The chunk data source type.</p> </li> <li> <code>index</code>               (<code>(int, optional)</code>)           \u2013            <p>The chunk index.</p> </li> <li> <code>page</code>               (<code>(int, optional)</code>)           \u2013            <p>The chunk page.</p> </li> <li> <code>start</code>               (<code>(int, optional)</code>)           \u2013            <p>The chunk start.</p> </li> <li> <code>end</code>               (<code>(int, optional)</code>)           \u2013            <p>The chunk end.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Document","title":"Document","text":"<p>               Bases: <code>BaseModel</code></p> <p>Document model.</p> <p>Attributes:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>The document ID.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The update datetime.</p> </li> <li> <code>workspace_ids</code>               (<code>list[str]</code>)           \u2013            <p>The workspace IDs.</p> </li> <li> <code>metadata</code>               (<code>DocumentMetadata</code>)           \u2013            <p>The document metadata.</p> </li> <li> <code>status</code>               (<code>str</code>)           \u2013            <p>The document status.</p> </li> <li> <code>tags</code>               (<code>(dict[str, Any], optional)</code>)           \u2013            <p>The document tags.</p> </li> <li> <code>user_metadata</code>               (<code>(dict[str, Any], optional)</code>)           \u2013            <p>The document user metadata.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.DocumentMetadata","title":"DocumentMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Document metadata model.</p> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>The document size.</p> </li> <li> <code>format</code>               (<code>str</code>)           \u2013            <p>The document format.</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The document filename.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Graph","title":"Graph","text":"<p>               Bases: <code>BaseModel</code></p> <p>Graph model.</p> <p>Attributes:</p> <ul> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The graph ID.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The graph name.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The update datetime.</p> </li> <li> <code>schema_id</code>               (<code>(str, optional)</code>)           \u2013            <p>The schema ID.</p> </li> <li> <code>status</code>               (<code>str</code>)           \u2013            <p>The graph status.</p> </li> <li> <code>errors</code>               (<code>(list[GraphErrorDetails], optional)</code>)           \u2013            <p>The graph errors.</p> </li> <li> <code>public</code>               (<code>(bool, optional)</code>)           \u2013            <p>The graph public status.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.GraphChunk","title":"GraphChunk","text":"<p>               Bases: <code>BaseModel</code></p> <p>Graph chunk model.</p> <p>Attributes:</p> <ul> <li> <code>chunk</code>               (<code>Chunk</code>)           \u2013            <p>The chunk.</p> </li> <li> <code>triples</code>               (<code>list[Triple]</code>)           \u2013            <p>The triples.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.GraphErrorDetails","title":"GraphErrorDetails","text":"<p>               Bases: <code>BaseModel</code></p> <p>Graph error details model.</p> <p>Attributes:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The error message.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>level</code>               (<code>str</code>)           \u2013            <p>The error level.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Node","title":"Node","text":"<p>               Bases: <code>BaseModel</code></p> <p>Node model.</p> <p>Attributes:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The node ID. It can be None since we allow for the user to also create nodes and only then send them to the server (that will generate the node ID).</p> </li> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The node label.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The node name.</p> </li> <li> <code>chunk_ids</code>               (<code>(list[str], optional)</code>)           \u2013            <p>The chunk IDs.</p> </li> <li> <code>properties</code>               (<code>(dict[str, Any], optional)</code>)           \u2013            <p>The node properties.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The update datetime.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Query","title":"Query","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query model.</p> <p>Attributes:</p> <ul> <li> <code>query_id</code>               (<code>str</code>)           \u2013            <p>The query ID.</p> </li> <li> <code>graph_id</code>               (<code>str</code>)           \u2013            <p>The graph ID.</p> </li> <li> <code>answer</code>               (<code>(str, optional)</code>)           \u2013            <p>The query answer.</p> </li> <li> <code>status</code>               (<code>str</code>)           \u2013            <p>The query status.</p> </li> <li> <code>nodes</code>               (<code>list[Node]</code>)           \u2013            <p>The query nodes.</p> </li> <li> <code>triples</code>               (<code>list[Triple]</code>)           \u2013            <p>The query triples.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The update datetime.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Relation","title":"Relation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Relation model.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The relation name.</p> </li> <li> <code>properties</code>               (<code>(dict[str, Any], optional)</code>)           \u2013            <p>The relation properties.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Schema","title":"Schema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema model.</p> <p>Attributes:</p> <ul> <li> <code>schema_id</code>               (<code>str</code>)           \u2013            <p>The schema ID.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The schema name.</p> </li> <li> <code>entities</code>               (<code>list[SchemaEntity]</code>)           \u2013            <p>The schema entities.</p> </li> <li> <code>relations</code>               (<code>list[SchemaRelation]</code>)           \u2013            <p>The schema relations.</p> </li> <li> <code>patterns</code>               (<code>list[SchemaTriplePattern]</code>)           \u2013            <p>The schema patterns.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The update datetime.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.SchemaEntity","title":"SchemaEntity","text":"<p>               Bases: <code>BaseModel</code></p> <p>Entity model.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The entity name.</p> </li> <li> <code>description</code>               (<code>(str, optional)</code>)           \u2013            <p>The entity description.</p> </li> <li> <code>fields</code>               (<code>(list[SchemaEntityField], optional)</code>)           \u2013            <p>The entity fields.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.SchemaEntityField","title":"SchemaEntityField","text":"<p>               Bases: <code>BaseModel</code></p> <p>Entity field model.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The field name.</p> </li> <li> <code>properties</code>               (<code>(list[str], optional)</code>)           \u2013            <p>The field properties.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.SchemaRelation","title":"SchemaRelation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Relation model.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The relation name.</p> </li> <li> <code>description</code>               (<code>(str, optional)</code>)           \u2013            <p>The relation description.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.SchemaTriplePattern","title":"SchemaTriplePattern","text":"<p>               Bases: <code>BaseModel</code></p> <p>Triple pattern model.</p> <p>Attributes:</p> <ul> <li> <code>head</code>               (<code>SchemaEntity</code>)           \u2013            <p>The head entity.</p> </li> <li> <code>relation</code>               (<code>SchemaRelation</code>)           \u2013            <p>The relation.</p> </li> <li> <code>tail</code>               (<code>SchemaEntity</code>)           \u2013            <p>The tail entity.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>The triple description.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Triple","title":"Triple","text":"<p>               Bases: <code>BaseModel</code></p> <p>Triple model.</p> <p>Attributes:</p> <ul> <li> <code>triple_id</code>               (<code>(str, optional)</code>)           \u2013            <p>The triple ID. It can be None since we allow for the user to also create triples and only then send them to the server (that will generate the triple ID).</p> </li> <li> <code>head</code>               (<code>Node</code>)           \u2013            <p>The head node.</p> </li> <li> <code>tail</code>               (<code>Node</code>)           \u2013            <p>The tail node.</p> </li> <li> <code>relation</code>               (<code>Relation</code>)           \u2013            <p>The relation.</p> </li> <li> <code>chunk_ids</code>               (<code>(list[str], optional)</code>)           \u2013            <p>The chunk IDs.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The update datetime.</p> </li> </ul>"},{"location":"api/#whyhow.schemas.Workspace","title":"Workspace","text":"<p>               Bases: <code>BaseModel</code></p> <p>Workspace model.</p> <p>Attributes:</p> <ul> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>The workspace ID.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The workspace name.</p> </li> <li> <code>created_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The creation datetime.</p> </li> <li> <code>updated_at</code>               (<code>(datetime, optional)</code>)           \u2013            <p>The update datetime.</p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>WhyHow API key</li> </ul>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>You can install the SDK directly from PyPI using pip:</p> <pre><code>pip install whyhow\n</code></pre>"},{"location":"installation/#install-from-github","title":"Install from Github","text":"<p>Alternatively, you can clone the repo and install the package</p> <pre><code>git clone git@github.com:whyhow-ai/whyhow.git\ncd whyhow\npip install .\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues during installation, please check the following:</p> <ul> <li>Ensure that you have Python 3.10 or higher installed. You can check your Python version by running <code>python --version</code> in your terminal.</li> <li>If you are installing from GitHub, ensure that you have cloned the repository correctly and are in the right directory.</li> <li>If you are using a virtual environment, make sure that it is activated before running the installation commands.</li> <li>If you still face problems, please open an issue on the GitHub repository with detailed information about the error and your environment setup.</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial will guide you through building and querying a knowledge graph using Amazon.com Inc.'s 2024 10-K filing and the provided schema. We'll use the WhyHow SDK to import relevant information from the 10-K document into a knowledge graph and then query it for insights related to Amazon's business.</p> <p>You can find the Amazon documents, schema, and many others here: https://github.com/whyhow-ai/schemas</p>"},{"location":"tutorial/#environment-setup","title":"Environment Setup","text":"<p>Ensure you have Python 3.10 or higher installed on your machine.</p> <p>To get started while we\u2019re in Beta, you\u2019ll need to get a Beta Access Key. You can do so by scheduling a call with us.</p> <p>If you already have access to our Platform Beta, you can retrieve your API keys in the Settings page of https://app.whyhow.ai/ or from email communication when you registered. </p> <p>After signing up, to get your API key, you can find it in the WhyHow settings page. To keep your API key secure, set it as an environment variable. Open your terminal and run the following command, substituting the placeholder with your actual data:</p> <pre><code>export WHYHOW_API_KEY=&lt;YOUR_WHYHOW_API_KEY&gt;\n</code></pre>"},{"location":"tutorial/#install-whyhow-sdk","title":"Install WhyHow SDK","text":"<p>If you haven't already, install the <code>WhyHow SDK</code> using pip:</p> <pre><code>pip install whyhow\n</code></pre>"},{"location":"tutorial/#configure-the-whyhow-client","title":"Configure the WhyHow Client","text":"<p>With your environment variable set, you can now configure the <code>WhyHow</code> client in your Python script. The client will automatically read in your environment variable, or you can override this value by specifying it in the client constructor.</p> <pre><code>from whyhow import WhyHow\n\nclient = WhyHow(api_key=&lt;your WhyHow API key&gt;, base_url=\"https://api.whyhow.ai\")\n</code></pre>"},{"location":"tutorial/#option-1-create-the-knowledge-graph-from-a-schema","title":"Option 1 - Create the Knowledge Graph from a schema","text":"<p>First, let's define the workspace for our project and specify the path to Amazon's 10-K document. Your workspace is a logical grouping of the raw data you upload, the schema you define, and the graphs you create.</p> <pre><code>workspace = client.workspaces.create(name=\"Amazon 10-K Analysis\")\n# or if you already have a workspace\n# workspace = client.workspaces.get(workspace_id=\"&lt;workspace_id&gt;\")\ndocument_path = \"path/to/amazon_10k_2024.pdf\"\n\n# Add document to your workspace\ndocument = client.documents.upload(\n    document_path,\n    workspace_id=workspace.workspace_id\n)\nprint(\"Document Added:\", document)\n</code></pre> <p>Next, we'll create a schema based on the provided JSON file. This schema defines the entities, relationships, and patterns we'll use to construct the graph.</p> <pre><code>from whyhow import SchemaEntity, SchemaRelation, SchemaTriplePattern\n\n# Load the schema from the JSON file\nentities, relations, patterns = client.schemas.load_json(\"amazon_10k_schema.json\")\n\nschema = client.schemas.create(\n    workspace_id=workspace.workspace_id,\n    name=\"Amazon 10-K Schema\",\n    entities=entities,\n    relations=relations,\n    patterns=patterns,\n)\n</code></pre> <p>Now, let's create the graph using the schema and the uploaded 10-K document:</p> <pre><code># Create graph from schema and document\ngraph = client.graphs.create(\n    workspace_id=workspace.workspace_id,\n    schema_id=schema.schema_id,\n    name=\"Amazon 10-K Graph\",\n)\n# Creating your graph\n</code></pre>"},{"location":"tutorial/#option-2-create-the-knowledge-graph-from-seed-questions","title":"Option 2 - Create the Knowledge Graph from seed questions","text":"<p>Alternatively, you can create a graph using seed concepts in the form of questions written in natural language. We'll create a new workspace and upload the same data.</p> <pre><code>workspace = client.workspaces.create(name=\"Amazon 10-K Analysis (Auto-Generated)\")\ndocument_path = \"path/to/amazon_10k_2024.pdf\"\n\n# Add document to your workspace\ndocument = client.documents.upload(\n    document_path,\n    workspace_id=workspace.workspace_id\n)\nprint(\"Document Added:\", document)\n</code></pre> <p>Create the schema from the seed questions:</p> <pre><code>questions = [\n    \"What are Amazon's primary business segments?\",\n    \"How does Amazon generate revenue?\",\n    \"What are the key risk factors for Amazon's business?\",\n    \"Who are Amazon's main competitors?\",\n    \"What is Amazon's strategy for future growth?\"\n]\n\nentities, relations, patterns = client.schemas.generate(\n    questions=questions,\n)\nprint(\"Entities:\", entities)\nprint(\"Relations:\", relations)\nprint(\"Patterns:\", patterns)\n\nschema = client.schemas.create(\n    workspace_id=workspace.workspace_id,\n    name=\"Amazon 10-K Auto-Generated Schema\",\n    entities=entities,\n    relations=relations,\n    patterns=patterns,\n)\n\n# Create graph from schema and document\ngraph_auto = client.graphs.create(\n    workspace_id=workspace.workspace_id,\n    schema_id=schema.schema_id,\n    name=\"Amazon 10-K Auto-Generated Graph\",\n)\n# Creating your graph\n</code></pre> <p>Now you can query the auto-generated graph:</p> <pre><code># Query the auto-generated graph\nquestion = \"What are Amazon's main revenue streams?\"\nquery = client.graphs.query_unstructured(\n    graph_id=graph_auto.graph_id,\n    query=question,\n)\nprint(\"Query Response:\", query.answer)\n\n# Query for specific competitive advantages\nquestion = \"What are Amazon's key competitive advantages?\"\nquery = client.graphs.query_unstructured(\n    graph_id=graph_auto.graph_id,\n    query=question,\n)\nprint(\"Query Response:\", query.answer)\n</code></pre> <p>This approach allows you to create a knowledge graph based on specific questions you're interested in exploring from the Amazon 10-K document. The auto-generated schema will focus on entities and relationships relevant to these questions, potentially providing a more targeted analysis of the document.</p>"},{"location":"tutorial/#option-3-create-knowledge-graph-from-importedexisting-triples","title":"Option 3 - Create Knowledge Graph from Imported/Existing Triples","text":"<pre><code># Let's say we want to create a new graph focusing on Amazon's revenue streams\nrevenue_triples = [\n    triple for triple in all_triples \n    if \"revenue\" in triple.head.label.lower() or \"revenue\" in triple.tail.label.lower()\n]\n\n# Create a new graph from these revenue-related triples\nrevenue_graph = client.graphs.create_graph_from_triples(\n    workspace_id=workspace.workspace_id,\n    triples=revenue_triples,\n    name=\"Amazon Revenue Streams Graph\",\n    schema_id=schema.schema_id,\n)\n\nprint(f\"Created new graph: {revenue_graph.name}\")\n\n# Now we can query this new, more focused graph\nquestion = \"What are Amazon's main sources of revenue?\"\nquery = client.graphs.query_unstructured(\n    graph_id=revenue_graph.graph_id,\n    query=question,\n)\nprint(\"Query Response:\", query.answer)\n\n# We can also get all triples from this new graph\nrevenue_graph_triples = list(client.graphs.get_all_triples(graph_id=revenue_graph.graph_id))\n\nprint(\"Triples in the Revenue Streams Graph:\")\nfor triple in revenue_graph_triples:\n    print(f\"Subject: {triple.head.name}, Relation: {triple.relation.name}, Object: {triple.tail.name}\")\n</code></pre>"},{"location":"tutorial/#querying-the-knowledge-graph","title":"Querying the Knowledge Graph","text":"<p>With the graph created, we can now query it to find specific information about Amazon's business:</p> <pre><code># Query graph for Amazon's business segments\nquestion = \"What are Amazon's main business segments?\"\nquery = client.graphs.query_unstructured(\n    graph_id=graph.graph_id,\n    query=question,\n)\nprint(\"Query Response:\", query.answer)\n\n# Query graph for Amazon's revenue streams\nquestion = \"What are Amazon's primary revenue streams?\"\nquery = client.graphs.query_unstructured(\n    graph_id=graph.graph_id,\n    query=question,\n)\nprint(\"Query Response:\", query.answer)\n\n# Include the chunks in the query\nquestion = \"What are the key risk factors for Amazon's business?\"\nquery = client.graphs.query_unstructured(\n    graph_id=graph.graph_id,\n    query=question,\n    include_chunks=True,\n)\nprint(\"Query Response:\", query.answer)\n\n# Query the graph for specific relations\nrelations = [\"comprises\", \"contributes_to\"]\n\nquery = client.graphs.query_structured(\n    graph_id=graph.graph_id,\n    relations=relations,\n)\nprint(\"Query Response:\", query.triples)\n</code></pre>"},{"location":"tutorial/#after-querying-the-graph-lets-retrieve-all-triples","title":"After querying the graph, let's retrieve all triples","text":"<pre><code>print(\"Retrieving all triples from the graph:\")\nall_triples = list(client.graphs.get_all_triples(graph_id=graph.graph_id))\n\nfor triple in all_triples:\n    print(f\"Subject: {triple.head}, Relation: {triple.relation}, Object: {triple.tail}\") \n</code></pre>"},{"location":"tutorial/#add-chunks-to-the-graph","title":"Add Chunks to the Graph","text":"<pre><code>document_path = \"path/to/amazon_10k_2023.pdf\"\n\nfor i in tqdm(range(0, len(text), 1024)):\n    chunk = text[i:i + 1024]\n    chunks = client.chunks.create(\n        workspace_id=workspace.workspace_id,\n        chunks=[\n            Chunk(\n                content=chunk\n            )\n        ]\n    )\n    client.graphs.add_chunks(\n        graph_id=graph.graph_id,\n        ids=[chunks[0].chunk_id]\n    )\n</code></pre>"},{"location":"tutorial/#add-triples-to-the-graph","title":"Add Triples to the Graph","text":"<pre><code>    triples = [\n        Triple(\n            head=Node(name=\"Amazon\", label=\"Company\"),\n            relation=Relation(name=\"Has business segment\"),\n            tail=Node(name=\"North America\", label=\"Business Segment\"),\n        ),\n        Triple(\n            head=Node(name=\"Amazon\", label=\"Company\"),\n            relation=Relation(name=\"Has business segment\"),\n            tail=Node(name=\"International\", label=\"Business Segment\"),\n        ),\n        Triple(\n            head=Node(name=\"Amazon\", label=\"Company\"),\n            relation=Relation(name=\"Has business segment\"),\n            tail=Node(name=\"AWS\", label=\"Business Segment\"),\n        ),\n        Triple(\n            head=Node(name=\"E-commerce\", label=\"Revenue Stream\"),\n            relation=Relation(name=\"Contributes to\"),\n            tail=Node(name=\"Amazon\", label=\"Company\"),\n        ),\n        Triple(\n            head=Node(name=\"Cloud computing services\", label=\"Revenue Stream\"),\n            relation=Relation(name=\"Contributes to\"),\n            tail=Node(name=\"AWS\", label=\"Business Segment\"),\n        ),\n    ]\n\n    graph = client.graphs.add(\n        graph_id=graph.graph_id,\n        triples=triples\n    )\n</code></pre>"},{"location":"tutorial/#exporting-the-knowledge-graph","title":"Exporting the Knowledge Graph","text":"<p>You can export the graph as a Cypher query to use in Neo4j or other graph databases:</p> <pre><code>cypher = client.graphs.export_cypher(graph_id=graph.graph_id)\nprint(cypher)\n</code></pre> <p>This tutorial demonstrates how to create a knowledge graph from Amazon's 10-K filing using the provided schema, and how to query the graph for insights into Amazon's business structure, revenue streams, and risk factors. You can expand on this by adding more specific queries or by analyzing different aspects of the 10-K document as needed for your analysis.</p>"},{"location":"examples/create_graph_from_triples/","title":"Create WhyHow Graph from Triples using LangChain","text":"In\u00a0[\u00a0]: Copied! <pre>import itertools\nimport os\nimport pickle\n\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_community.document_loaders import PyPDFLoader\nfrom langchain_experimental.graph_transformers import LLMGraphTransformer\nfrom langchain_openai import ChatOpenAI\n\nfrom whyhow import WhyHow, Node, Relation, Triple\n</pre> import itertools import os import pickle  from langchain.text_splitter import RecursiveCharacterTextSplitter from langchain_community.document_loaders import PyPDFLoader from langchain_experimental.graph_transformers import LLMGraphTransformer from langchain_openai import ChatOpenAI  from whyhow import WhyHow, Node, Relation, Triple In\u00a0[\u00a0]: Copied! <pre>from dotenv import find_dotenv, load_dotenv\nload_dotenv(find_dotenv())\n</pre> from dotenv import find_dotenv, load_dotenv load_dotenv(find_dotenv()) In\u00a0[\u00a0]: Copied! <pre>llm = ChatOpenAI(model=\"gpt-4o\")\nllm_transformer = LLMGraphTransformer(llm=llm)\n</pre> llm = ChatOpenAI(model=\"gpt-4o\") llm_transformer = LLMGraphTransformer(llm=llm) In\u00a0[\u00a0]: Copied! <pre>filepath = \"{YOUR FILEPATH}\"\n</pre> filepath = \"{YOUR FILEPATH}\" In\u00a0[\u00a0]: Copied! <pre>loader = PyPDFLoader(filepath)\ndocs = loader.load()\n</pre> loader = PyPDFLoader(filepath) docs = loader.load() In\u00a0[\u00a0]: Copied! <pre>text_splitter = RecursiveCharacterTextSplitter(chunk_size=2000, chunk_overlap=0)\nsplit_docs = text_splitter.split_documents(docs)\n</pre> text_splitter = RecursiveCharacterTextSplitter(chunk_size=2000, chunk_overlap=0) split_docs = text_splitter.split_documents(docs) In\u00a0[\u00a0]: Copied! <pre># Select the entity types and realtions you want for your triples\nallowed_nodes=[\"Company\", \"Risk Factor\", \"Legal Proceeding\", \"Business Segment\"]\nallowed_relationships=[\"AFFECTS\", \"INVOLVED_IN\", \"WORKED_AT\", \"POSES_RISK\"]\n</pre> # Select the entity types and realtions you want for your triples allowed_nodes=[\"Company\", \"Risk Factor\", \"Legal Proceeding\", \"Business Segment\"] allowed_relationships=[\"AFFECTS\", \"INVOLVED_IN\", \"WORKED_AT\", \"POSES_RISK\"] In\u00a0[\u00a0]: Copied! <pre>llm_transformer_props = LLMGraphTransformer(\n    llm=llm,\n    allowed_nodes=updated_allowed_nodes,\n    allowed_relationships=updated_allowed_relationships\n)\n</pre> llm_transformer_props = LLMGraphTransformer(     llm=llm,     allowed_nodes=updated_allowed_nodes,     allowed_relationships=updated_allowed_relationships ) In\u00a0[\u00a0]: Copied! <pre>graph_documents_props = await llm_transformer_props.aconvert_to_graph_documents(split_docs)\n</pre> graph_documents_props = await llm_transformer_props.aconvert_to_graph_documents(split_docs) In\u00a0[\u00a0]: Copied! <pre>print(f\"Nodes:{graph_documents_props[0].nodes}\")\nprint(f\"Relationships:{graph_documents_props[0].relationships}\")\n</pre> print(f\"Nodes:{graph_documents_props[0].nodes}\") print(f\"Relationships:{graph_documents_props[0].relationships}\") In\u00a0[\u00a0]: Copied! <pre>for i in range(10):\n    print(graph_documents_props[i].relationships)\n</pre> for i in range(10):     print(graph_documents_props[i].relationships) In\u00a0[\u00a0]: Copied! <pre>triples = [chunk.relationships for chunk in graph_documents_props]\nflat_triples = list(itertools.chain(*triples))\n</pre> triples = [chunk.relationships for chunk in graph_documents_props] flat_triples = list(itertools.chain(*triples)) In\u00a0[\u00a0]: Copied! <pre>flat_triples[0]\n</pre> flat_triples[0] In\u00a0[\u00a0]: Copied! <pre># Serialize the list and write it to the file\nwith open('langchain_triples_improved.pkl', 'wb') as file:\n    pickle.dump(flat_triples, file)\n</pre> # Serialize the list and write it to the file with open('langchain_triples_improved.pkl', 'wb') as file:     pickle.dump(flat_triples, file) In\u00a0[346]: Copied! <pre># Initialise the client with your WhyHow API key\nclient = WhyHow(api_key=os.environ[\"WHYHOW_API_KEY\"], base_url=\"https://api.whyhow.ai\")\n</pre> # Initialise the client with your WhyHow API key client = WhyHow(api_key=os.environ[\"WHYHOW_API_KEY\"], base_url=\"https://api.whyhow.ai\") In\u00a0[331]: Copied! <pre>workspace = client.workspaces.create(name=\"Amazon 10-K Testing\")\n# or, if you already have a workspace\n# workspace = client.workspaces.get(workspace_id=\"&lt;workspace_id&gt;\")\n</pre> workspace = client.workspaces.create(name=\"Amazon 10-K Testing\") # or, if you already have a workspace # workspace = client.workspaces.get(workspace_id=\"\") In\u00a0[\u00a0]: Copied! <pre>with open('langchain_triples.pkl', 'rb') as file:\n    flat_triples = pickle.load(file)\n</pre> with open('langchain_triples.pkl', 'rb') as file:     flat_triples = pickle.load(file) In\u00a0[\u00a0]: Copied! <pre>flat_triples[0]\n</pre> flat_triples[0] In\u00a0[\u00a0]: Copied! <pre>def format_triple(triple):\n    \"\"\"\n    Format the LangChain triple into the desired structure.\n\n    Args:\n        triple: An object containing source, target, and type attributes.\n\n    Returns:\n        Triple: A Triple object with formatted head, relation, and tail.\n    \"\"\"\n    # Extract source and target from the triple\n    source = triple.source\n    target = triple.target\n    \n    # Create and return a formatted Triple object\n    return Triple(\n        head=Node(name=source.id, label=source.type),  # Head node with source id and type\n        relation=Relation(name=triple.type),           # Relation with triple type\n        tail=Node(name=target.id, label=target.type)   # Tail node with target id and type\n    )\n</pre> def format_triple(triple):     \"\"\"     Format the LangChain triple into the desired structure.      Args:         triple: An object containing source, target, and type attributes.      Returns:         Triple: A Triple object with formatted head, relation, and tail.     \"\"\"     # Extract source and target from the triple     source = triple.source     target = triple.target          # Create and return a formatted Triple object     return Triple(         head=Node(name=source.id, label=source.type),  # Head node with source id and type         relation=Relation(name=triple.type),           # Relation with triple type         tail=Node(name=target.id, label=target.type)   # Tail node with target id and type     ) In\u00a0[\u00a0]: Copied! <pre># Generate a list of formatted triples with indices\nformatted_triples = [format_triple(triple) for triple in flat_triples]\n</pre> # Generate a list of formatted triples with indices formatted_triples = [format_triple(triple) for triple in flat_triples] In\u00a0[\u00a0]: Copied! <pre># View the first 3 triples\nformatted_triples[:1]\n</pre> # View the first 3 triples formatted_triples[:1]  In\u00a0[333]: Copied! <pre>graph = client.graphs.create_graph_from_triples(\n    workspace_id=workspace.workspace_id,\n    triples=formatted_triples,\n    name=\"Amazon 10-K Graph (triple id testing 5)\"  \n)\n</pre> graph = client.graphs.create_graph_from_triples(     workspace_id=workspace.workspace_id,     triples=formatted_triples,     name=\"Amazon 10-K Graph (triple id testing 5)\"   ) In\u00a0[337]: Copied! <pre># Query graph for Amazon's business segments\nquestion = \"What are Amazons main business segments?\"\n\nquery_response = client.graphs.query_unstructured(\n    graph_id='66cbd0f8781bfda4a5a4e2ef',\n    query=question,\n)\n</pre> # Query graph for Amazon's business segments question = \"What are Amazons main business segments?\"  query_response = client.graphs.query_unstructured(     graph_id='66cbd0f8781bfda4a5a4e2ef',     query=question, ) In\u00a0[338]: Copied! <pre>print(f\"LLM Response: {query_response.answer}\")\nprint(f\"Returned Triples: {query_response.triples}\")\n</pre> print(f\"LLM Response: {query_response.answer}\") print(f\"Returned Triples: {query_response.triples}\") <pre>LLM Response: North America, Amazon Web Services (AWS), International.\nReturned Triples: [Triple(triple_id='66cbd0fc781bfda4a5a4e751', head=Node(node_id='66cbd0f8781bfda4a5a4e2fc', label='Company', name='Amazon.Com, Inc.', chunk_ids=[], properties={}, created_at=None, updated_at=None), tail=Node(node_id='66cbd0f8781bfda4a5a4e300', label='Business segment', name='North America', chunk_ids=[], properties={}, created_at=None, updated_at=None), relation=Relation(name='INVOLVED_IN', properties={}), chunk_ids=[], created_at=None, updated_at=None), Triple(triple_id='66cbd0fc781bfda4a5a4e752', head=Node(node_id='66cbd0f8781bfda4a5a4e2fc', label='Company', name='Amazon.Com, Inc.', chunk_ids=[], properties={}, created_at=None, updated_at=None), tail=Node(node_id='66cbd0f8781bfda4a5a4e301', label='Business segment', name='International', chunk_ids=[], properties={}, created_at=None, updated_at=None), relation=Relation(name='INVOLVED_IN', properties={}), chunk_ids=[], created_at=None, updated_at=None), Triple(triple_id='66cbd0fc781bfda4a5a4e753', head=Node(node_id='66cbd0f8781bfda4a5a4e2fc', label='Company', name='Amazon.Com, Inc.', chunk_ids=[], properties={}, created_at=None, updated_at=None), tail=Node(node_id='66cbd0f8781bfda4a5a4e302', label='Business segment', name='Amazon Web Services (Aws)', chunk_ids=[], properties={}, created_at=None, updated_at=None), relation=Relation(name='INVOLVED_IN', properties={}), chunk_ids=[], created_at=None, updated_at=None)]\n</pre>"},{"location":"examples/create_graph_from_triples/#create-whyhow-graph-from-triples-using-langchain","title":"Create WhyHow Graph from Triples using LangChain\u00b6","text":""},{"location":"examples/create_graph_from_triples/#load-text-from-selected-file","title":"Load Text from Selected File\u00b6","text":""},{"location":"examples/create_graph_from_triples/#process-document","title":"Process Document\u00b6","text":""},{"location":"examples/create_graph_from_triples/#convert-processed-text-to-triples","title":"Convert Processed Text to Triples\u00b6","text":""},{"location":"examples/create_graph_from_triples/#optional-store-the-triples","title":"[Optional] Store the Triples\u00b6","text":""},{"location":"examples/create_graph_from_triples/#whyhow-integration","title":"WhyHow Integration\u00b6","text":""},{"location":"examples/create_graph_from_triples/#initialise-the-workspace","title":"Initialise the Workspace\u00b6","text":""},{"location":"examples/create_graph_from_triples/#optional-load-the-triples","title":"[Optional] Load the Triples\u00b6","text":""},{"location":"examples/create_graph_from_triples/#preprocess-the-triples","title":"Preprocess the Triples\u00b6","text":""},{"location":"examples/create_graph_from_triples/#create-the-graph","title":"Create the graph\u00b6","text":""},{"location":"examples/create_graph_from_triples/#query-the-graph","title":"Query the graph\u00b6","text":""},{"location":"examples/overview/","title":"Examples","text":"<p>Welcome to the WhyHow SDK Examples! This section contains practical demonstrations of how to use the WhyHow SDK for various tasks.</p>"},{"location":"examples/overview/#available-examples","title":"Available Examples","text":"<ol> <li>Create Graph from Triples</li> </ol> <p>Demonstrates how to create a graph from triples using LangChain's LLMGraphTransformer</p> <ol> <li>Update Existing Graph</li> </ol> <p>Updates an existing graph with new chunks</p> <ol> <li>Query Completeness</li> </ol> <p>Demonstrates how graphs can enable query completeness</p> <p>Click on each example to view the detailed walkthrough and code.</p>"},{"location":"examples/query_completeness/","title":"Query completeness","text":"In\u00a0[42]: Copied! <pre>from llmsherpa.readers import LayoutPDFReader\nimport llmsherpa\nimport os\nimport json\n\n\nfrom langchain_experimental.graph_transformers import LLMGraphTransformer\nfrom langchain_openai import ChatOpenAI\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain.embeddings.openai import OpenAIEmbeddings\n\nfrom openai import OpenAI\nfrom whyhow import Triple, Node, Relation, WhyHow\n\nos.environ['PINECONE_API_KEY'] = \"&lt;pinecone api key&gt;\"\nos.environ['OPENAI_API_KEY'] = \"&lt;openai api key&gt;\"\n\nwhyhow_client = WhyHow(api_key=\"&lt;whyhow api key&gt;\", base_url=\"https://api.whyhow.ai\")\n\n# Requires that nlm-ingester is running - https://github.com/nlmatics/nlm-ingestor\npdf_reader = LayoutPDFReader(\"http://localhost:5010/api/parseDocument?renderFormat=all\")\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=2000, chunk_overlap=0)\n\nllm = ChatOpenAI(model=\"gpt-4o\")\nllm_transformer = LLMGraphTransformer(llm=llm)\n\n\nopenai_client = OpenAI()\n</pre> from llmsherpa.readers import LayoutPDFReader import llmsherpa import os import json   from langchain_experimental.graph_transformers import LLMGraphTransformer from langchain_openai import ChatOpenAI from langchain.text_splitter import RecursiveCharacterTextSplitter from langchain.embeddings.openai import OpenAIEmbeddings  from openai import OpenAI from whyhow import Triple, Node, Relation, WhyHow  os.environ['PINECONE_API_KEY'] = \"\" os.environ['OPENAI_API_KEY'] = \"\"  whyhow_client = WhyHow(api_key=\"\", base_url=\"https://api.whyhow.ai\")  # Requires that nlm-ingester is running - https://github.com/nlmatics/nlm-ingestor pdf_reader = LayoutPDFReader(\"http://localhost:5010/api/parseDocument?renderFormat=all\") text_splitter = RecursiveCharacterTextSplitter(chunk_size=2000, chunk_overlap=0)  llm = ChatOpenAI(model=\"gpt-4o\") llm_transformer = LLMGraphTransformer(llm=llm)   openai_client = OpenAI() In\u00a0[47]: Copied! <pre># Specify docs to process\nsec_10k_docs = [\n    {\n        \"company\": \"Walmart\",\n        \"year\": 2024,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/b9745621-712b-43d0-b8e9-5cf33db255e3.pdf\"\n    },\n    {\n        \"company\": \"Walmart\",\n        \"year\": 2023,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/dfe6ee99-8fe6-4333-80ac-829d9e7595fa.pdf\"\n    },\n    {\n        \"company\": \"Walmart\",\n        \"year\": 2022,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/c68fb8be-2602-4f2a-aee0-261b4f04b970.pdf\"\n    },\n    {\n        \"company\": \"Walmart\",\n        \"year\": 2021,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/598c8825-536a-4371-ab8a-98b9ee761c43.pdf\"\n    },\n    {\n        \"company\": \"Walmart\",\n        \"year\": 2020,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/af5415d9-0e07-4ba1-a6cc-bb3058a7f4e8.pdf\"\n    },\n    {\n        \"company\": \"Amazon\",\n        \"year\": 2024,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/c7c14359-36fa-40c3-b3ca-5bf7f3fa0b96.pdf\"\n    },\n    {\n        \"company\": \"Amazon\",\n        \"year\": 2023,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/d2fde7ee-05f7-419d-9ce8-186de4c96e25.pdf\"\n    },\n    {\n        \"company\": \"Amazon\",\n        \"year\": 2022,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/f965e5c3-fded-45d3-bbdb-f750f156dcc9.pdf\"\n    },\n    {\n        \"company\": \"Amazon\",\n        \"year\": 2021,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/336d8745-ea82-40a5-9acc-1a89df23d0f3.pdf\"\n    },\n    {\n        \"company\": \"Amazon\",\n        \"year\": 2020,\n        \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/4d39f579-19d8-4119-b087-ee618abf82d6.pdf\"\n    }\n]\n</pre> # Specify docs to process sec_10k_docs = [     {         \"company\": \"Walmart\",         \"year\": 2024,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/b9745621-712b-43d0-b8e9-5cf33db255e3.pdf\"     },     {         \"company\": \"Walmart\",         \"year\": 2023,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/dfe6ee99-8fe6-4333-80ac-829d9e7595fa.pdf\"     },     {         \"company\": \"Walmart\",         \"year\": 2022,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/c68fb8be-2602-4f2a-aee0-261b4f04b970.pdf\"     },     {         \"company\": \"Walmart\",         \"year\": 2021,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/598c8825-536a-4371-ab8a-98b9ee761c43.pdf\"     },     {         \"company\": \"Walmart\",         \"year\": 2020,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0000104169/af5415d9-0e07-4ba1-a6cc-bb3058a7f4e8.pdf\"     },     {         \"company\": \"Amazon\",         \"year\": 2024,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/c7c14359-36fa-40c3-b3ca-5bf7f3fa0b96.pdf\"     },     {         \"company\": \"Amazon\",         \"year\": 2023,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/d2fde7ee-05f7-419d-9ce8-186de4c96e25.pdf\"     },     {         \"company\": \"Amazon\",         \"year\": 2022,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/f965e5c3-fded-45d3-bbdb-f750f156dcc9.pdf\"     },     {         \"company\": \"Amazon\",         \"year\": 2021,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/336d8745-ea82-40a5-9acc-1a89df23d0f3.pdf\"     },     {         \"company\": \"Amazon\",         \"year\": 2020,         \"url\": \"https://d18rn0p25nwr6d.cloudfront.net/CIK-0001018724/4d39f579-19d8-4119-b087-ee618abf82d6.pdf\"     } ] In\u00a0[\u00a0]: Copied! <pre>import re \nimport uuid\nimport datetime\nimport itertools\n\nfrom langchain.document_loaders import PyPDFLoader\nfrom pinecone import Pinecone, Index\nfrom typing import List, Dict, Union\n\npinecone_key = os.getenv(\"PINECONE_API_KEY\")\npc = Pinecone(api_key=pinecone_key)\nindex = pc.Index(\"&lt;index name&gt;\")\n\ndef generate_namespace() -&gt; str:\n    \"\"\"\n    Generate a unique namespace.\n\n    Returns:\n    str: The generated namespace.\n    \"\"\"\n    unique_id = str(uuid.uuid4())\n    date = datetime.date.today()\n    date = re.sub('[^0-9a-zA-Z ]+', '_', str(date))\n    namespace = '_'.join((date, unique_id))\n    return namespace\n\ndef split_document(doc: str) -&gt; List[str]:\n    \"\"\"\n    Split a document into chunks.\n\n    Parameters:\n    doc (str): The document to split.\n\n    Returns:\n    List[str]: The list of chunks.\n    \"\"\"\n    loader = PyPDFLoader(doc)\n    docs = loader.load()\n    splitter = RecursiveCharacterTextSplitter(chunk_size=2000)\n    chunks = splitter.split_documents(docs)\n    return chunks\n\ndef clean_chunks(chunks: List[str]) -&gt; List[str]:\n    \"\"\"\n    Clean a list of chunks.\n\n    Parameters:\n    chunks (List[str]): The list of chunks to clean.\n\n    Returns:\n    List[str]: The list of cleaned chunks.\n    \"\"\"\n    clean_chunks = []\n    for chunk in chunks:\n      clean_chunks.append(re.sub('/(\\r\\n|\\n|\\r)/gm', '',chunk.page_content))\n      print(chunk)\n\n    return clean_chunks\n\ndef generate_vectors(chunks: List[str], document_id: str) -&gt; List[Dict[str, Union[str, List[float], Dict[str, str]]]]:\n    \"\"\"\n    Generate vectors for a list of chunks.\n\n    Parameters:\n    chunks (List[str]): The list of chunks to generate vectors for.\n    document_id (str): The id of the document the chunks belong to.\n\n    Returns:\n    List[Dict[str, Union[str, List[float], Dict[str, str]]]]: The list of generated vectors.\n    \"\"\"\n\n    clean_chunk_array = []\n\n    for chunk in chunks:\n\n      # Clean up the chunk and remove unnecessary text\n      clean_chunk = re.sub('/(\\r\\n|\\n|\\r)/gm', '',chunk.page_content)\n      clean_chunk_array.append(clean_chunk)\n\n\n    embeddings = OpenAIEmbeddings()\n    embeddings_array = embeddings.embed_documents(clean_chunk_array)\n\n    vectors = []\n\n    for i, chunk in enumerate(chunks):\n      page_chunk_count = 0\n      page = chunk.metadata['page'] + 1\n      vectors.append({\n        'id': chunk.metadata['source']+'_'+str(page)+'_'+str(i),\n        'values': embeddings_array[i],\n        'metadata': {\n          'page': page,\n          'pageContent': chunk.page_content,\n          'filename': chunk.metadata['source'],\n          'documentId': document_id\n        },\n      })\n\n    return vectors\n\ndef upload_vectors(index: Index, vectors: List[Dict[str, Union[str, List[float], Dict[str, str]]]], namespace: str):\n    \"\"\"\n    Upload a list of vectors to an index.\n\n    Parameters:\n    index (pc.Index): The index to upload to.\n    vectors (List[Dict[str, Union[str, List[float], Dict[str, str]]]]): The list of vectors to upload.\n    namespace (str): The namespace to upload to.\n    \"\"\"\n    def chunks(iterable, batch_size=100):\n        it = iter(iterable)\n        chunk = tuple(itertools.islice(it, batch_size))\n        while chunk:\n            yield chunk\n            chunk = tuple(itertools.islice(it, batch_size))\n\n    for vectors_chunk in chunks(vectors, batch_size=100):\n        result = index.upsert(vectors=vectors_chunk, namespace=namespace)\n        print(result)\n\ndef upload_docs(index_name: str, documents: List[str]) -&gt; Dict[str, Union[str, List[Dict[str, str]]]]:\n    \"\"\"\n    Upload documents to an index.\n\n    Parameters:\n    index_name (str): The name of the index to upload to.\n    documents (List[str]): The documents to upload.\n\n    Returns:\n    dict: A dictionary containing the namespace and the names of the uploaded documents.\n    \"\"\"\n    document_names = []\n    namespace = generate_namespace()\n    index = pc.Index(index_name)\n\n    for doc in documents:\n        document_id = str(uuid.uuid4())\n        chunks = split_document(doc)\n        document_names.append({'source': chunks[0].metadata['source'], 'documentId': document_id})\n        print(document_names)\n        vectors = generate_vectors(chunks, document_id)\n        print(len(vectors), ' vectors uploaded')\n        upload_vectors(index, vectors, namespace)\n\n    return {'namespace': namespace, 'documents': document_names}\n\ndocs = [\n    \"../10k_docs/amzn_10k_2020.pdf\",\n    \"../10k_docs/amzn_10k_2021.pdf\",\n    \"../10k_docs/amzn_10k_2022.pdf\",\n    \"../10k_docs/amzn_10k_2023.pdf\",\n    \"../10k_docs/amzn_10k_2024.pdf\",\n    \"../10k_docs/wmt_10k_2020.pdf\",\n    \"../10k_docs/wmt_10k_2021.pdf\",\n    \"../10k_docs/wmt_10k_2022.pdf\",\n    \"../10k_docs/wmt_10k_2023.pdf\",\n    \"../10k_docs/wmt_10k_2024.pdf\",\n]\n\nupload_docs(\"&lt;index name&gt;\",docs)\n</pre> import re  import uuid import datetime import itertools  from langchain.document_loaders import PyPDFLoader from pinecone import Pinecone, Index from typing import List, Dict, Union  pinecone_key = os.getenv(\"PINECONE_API_KEY\") pc = Pinecone(api_key=pinecone_key) index = pc.Index(\"\")  def generate_namespace() -&gt; str:     \"\"\"     Generate a unique namespace.      Returns:     str: The generated namespace.     \"\"\"     unique_id = str(uuid.uuid4())     date = datetime.date.today()     date = re.sub('[^0-9a-zA-Z ]+', '_', str(date))     namespace = '_'.join((date, unique_id))     return namespace  def split_document(doc: str) -&gt; List[str]:     \"\"\"     Split a document into chunks.      Parameters:     doc (str): The document to split.      Returns:     List[str]: The list of chunks.     \"\"\"     loader = PyPDFLoader(doc)     docs = loader.load()     splitter = RecursiveCharacterTextSplitter(chunk_size=2000)     chunks = splitter.split_documents(docs)     return chunks  def clean_chunks(chunks: List[str]) -&gt; List[str]:     \"\"\"     Clean a list of chunks.      Parameters:     chunks (List[str]): The list of chunks to clean.      Returns:     List[str]: The list of cleaned chunks.     \"\"\"     clean_chunks = []     for chunk in chunks:       clean_chunks.append(re.sub('/(\\r\\n|\\n|\\r)/gm', '',chunk.page_content))       print(chunk)      return clean_chunks  def generate_vectors(chunks: List[str], document_id: str) -&gt; List[Dict[str, Union[str, List[float], Dict[str, str]]]]:     \"\"\"     Generate vectors for a list of chunks.      Parameters:     chunks (List[str]): The list of chunks to generate vectors for.     document_id (str): The id of the document the chunks belong to.      Returns:     List[Dict[str, Union[str, List[float], Dict[str, str]]]]: The list of generated vectors.     \"\"\"      clean_chunk_array = []      for chunk in chunks:        # Clean up the chunk and remove unnecessary text       clean_chunk = re.sub('/(\\r\\n|\\n|\\r)/gm', '',chunk.page_content)       clean_chunk_array.append(clean_chunk)       embeddings = OpenAIEmbeddings()     embeddings_array = embeddings.embed_documents(clean_chunk_array)      vectors = []      for i, chunk in enumerate(chunks):       page_chunk_count = 0       page = chunk.metadata['page'] + 1       vectors.append({         'id': chunk.metadata['source']+'_'+str(page)+'_'+str(i),         'values': embeddings_array[i],         'metadata': {           'page': page,           'pageContent': chunk.page_content,           'filename': chunk.metadata['source'],           'documentId': document_id         },       })      return vectors  def upload_vectors(index: Index, vectors: List[Dict[str, Union[str, List[float], Dict[str, str]]]], namespace: str):     \"\"\"     Upload a list of vectors to an index.      Parameters:     index (pc.Index): The index to upload to.     vectors (List[Dict[str, Union[str, List[float], Dict[str, str]]]]): The list of vectors to upload.     namespace (str): The namespace to upload to.     \"\"\"     def chunks(iterable, batch_size=100):         it = iter(iterable)         chunk = tuple(itertools.islice(it, batch_size))         while chunk:             yield chunk             chunk = tuple(itertools.islice(it, batch_size))      for vectors_chunk in chunks(vectors, batch_size=100):         result = index.upsert(vectors=vectors_chunk, namespace=namespace)         print(result)  def upload_docs(index_name: str, documents: List[str]) -&gt; Dict[str, Union[str, List[Dict[str, str]]]]:     \"\"\"     Upload documents to an index.      Parameters:     index_name (str): The name of the index to upload to.     documents (List[str]): The documents to upload.      Returns:     dict: A dictionary containing the namespace and the names of the uploaded documents.     \"\"\"     document_names = []     namespace = generate_namespace()     index = pc.Index(index_name)      for doc in documents:         document_id = str(uuid.uuid4())         chunks = split_document(doc)         document_names.append({'source': chunks[0].metadata['source'], 'documentId': document_id})         print(document_names)         vectors = generate_vectors(chunks, document_id)         print(len(vectors), ' vectors uploaded')         upload_vectors(index, vectors, namespace)      return {'namespace': namespace, 'documents': document_names}  docs = [     \"../10k_docs/amzn_10k_2020.pdf\",     \"../10k_docs/amzn_10k_2021.pdf\",     \"../10k_docs/amzn_10k_2022.pdf\",     \"../10k_docs/amzn_10k_2023.pdf\",     \"../10k_docs/amzn_10k_2024.pdf\",     \"../10k_docs/wmt_10k_2020.pdf\",     \"../10k_docs/wmt_10k_2021.pdf\",     \"../10k_docs/wmt_10k_2022.pdf\",     \"../10k_docs/wmt_10k_2023.pdf\",     \"../10k_docs/wmt_10k_2024.pdf\", ]  upload_docs(\"\",docs) In\u00a0[\u00a0]: Copied! <pre>query = \"What are the lawsuits that Amazon is facing?\"\n\nchunks_extracted = 0\n\nindex = pc.Index(\"&lt;index name&gt;\")\n\nconcatenatedChunks = \"\"\nembeddings = OpenAIEmbeddings()\nquery_embedding = embeddings.embed_query(query)\n\nquery_response = index.query(\n        namespace=\"&lt;namespace name&gt;\",\n        top_k=64,\n        vector=query_embedding,\n        include_metadata=True\n    )\n\nfor chunk in query_response.matches:\n    concatenatedChunks += chunk.metadata['pageContent'] + ' '\n    chunks_extracted += 1\n</pre> query = \"What are the lawsuits that Amazon is facing?\"  chunks_extracted = 0  index = pc.Index(\"\")  concatenatedChunks = \"\" embeddings = OpenAIEmbeddings() query_embedding = embeddings.embed_query(query)  query_response = index.query(         namespace=\"\",         top_k=64,         vector=query_embedding,         include_metadata=True     )  for chunk in query_response.matches:     concatenatedChunks += chunk.metadata['pageContent'] + ' '     chunks_extracted += 1  In\u00a0[\u00a0]: Copied! <pre>answer_prompt = f\"\"\"\n        Context:\n        You are a helpful chatbot. Your job is to anwer the following question using only the context provided in the Context below:\n\n        Question: {query}\n        Context: {concatenatedChunks}\n\n        Answer:\"\"\"\n\nresponse = openai_client.chat.completions.create(\n    model=\"gpt-4o\",\n    messages=[{\n        \"role\": \"user\",\n        \"content\": answer_prompt\n    }],\n    max_tokens=4000\n)\n\nprint(response.choices[0].message.content)\n</pre> answer_prompt = f\"\"\"         Context:         You are a helpful chatbot. Your job is to anwer the following question using only the context provided in the Context below:          Question: {query}         Context: {concatenatedChunks}          Answer:\"\"\"  response = openai_client.chat.completions.create(     model=\"gpt-4o\",     messages=[{         \"role\": \"user\",         \"content\": answer_prompt     }],     max_tokens=4000 )  print(response.choices[0].message.content) In\u00a0[5]: Copied! <pre>async def process_customprompt(section_text, company_name):\n\n    prompt = f\"\"\"\n        Using the content below, extract the companies involved and output it in following JSON format:\n\n        [{{\"head\": {{\"type\": \"Company\", \"id\": {company_name}}}, \"relation\": \"INVOLVED_IN\", \"tail\": {{\"type\": \"Legal Proceeding\", \"id\": &lt;legal proceeding name&gt;}}}}, ...]\n\n        Do not include supporting information. Do not wrap the response in JSON markers. If there is no relevant information, just return an empty array.\n        Content:{section_text}\n    \"\"\"\n    response = openai_client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[\n            {\"role\": \"user\", \"content\": prompt},\n        ],\n        max_tokens=4000,\n        temperature=0.1\n    )\n\n    triples = json.loads(response.choices[0].message.content)\n    return triples\n</pre> async def process_customprompt(section_text, company_name):      prompt = f\"\"\"         Using the content below, extract the companies involved and output it in following JSON format:          [{{\"head\": {{\"type\": \"Company\", \"id\": {company_name}}}, \"relation\": \"INVOLVED_IN\", \"tail\": {{\"type\": \"Legal Proceeding\", \"id\": }}}}, ...]          Do not include supporting information. Do not wrap the response in JSON markers. If there is no relevant information, just return an empty array.         Content:{section_text}     \"\"\"     response = openai_client.chat.completions.create(         model=\"gpt-4o\",         messages=[             {\"role\": \"user\", \"content\": prompt},         ],         max_tokens=4000,         temperature=0.1     )      triples = json.loads(response.choices[0].message.content)     return triples  In\u00a0[48]: Copied! <pre>custom_prompt_triples = []\n\nfor pdf in sec_10k_docs:\n    doc = pdf_reader.read_pdf(pdf[\"url\"])\n\n    for section in doc.sections():\n\n        if \"Legal Proceedings\" in section.to_text():\n            section_text = section.to_text(include_children=True, recurse=True)\n\n            # # Get triples from custom prompt\n            custom_prompt_out = await process_customprompt(section_text, pdf[\"company\"])\n            custom_prompt_triples.extend(custom_prompt_out)\n</pre> custom_prompt_triples = []  for pdf in sec_10k_docs:     doc = pdf_reader.read_pdf(pdf[\"url\"])      for section in doc.sections():          if \"Legal Proceedings\" in section.to_text():             section_text = section.to_text(include_children=True, recurse=True)              # # Get triples from custom prompt             custom_prompt_out = await process_customprompt(section_text, pdf[\"company\"])             custom_prompt_triples.extend(custom_prompt_out) In\u00a0[\u00a0]: Copied! <pre>formatted_triples = []\n\ndef format_custom_triple(triple):\n\n    head = triple['head']\n    tail = triple['tail']\n    \n    return Triple(\n        head=Node(name=head['id'], label=head['type']),\n        relation=Relation(name=triple['relation']),      \n        tail=Node(name=tail['id'], label=tail['type']) \n    )\n\nformatted_triples = [format_custom_triple(triple) for triple in custom_prompt_triples]\n</pre> formatted_triples = []  def format_custom_triple(triple):      head = triple['head']     tail = triple['tail']          return Triple(         head=Node(name=head['id'], label=head['type']),         relation=Relation(name=triple['relation']),               tail=Node(name=tail['id'], label=tail['type'])      )  formatted_triples = [format_custom_triple(triple) for triple in custom_prompt_triples] In\u00a0[51]: Copied! <pre># Create workspace\nworkspace = whyhow_client.workspaces.create(name=\"&lt;workspace name&gt;\")\n\n# Build graph from formatted triples\ngraph = whyhow_client.graphs.create_graph_from_triples(\n    workspace_id=workspace.workspace_id,\n    triples=formatted_triples,\n    name=\"&lt;graph name&gt;\"\n)\n</pre> # Create workspace workspace = whyhow_client.workspaces.create(name=\"\")  # Build graph from formatted triples graph = whyhow_client.graphs.create_graph_from_triples(     workspace_id=workspace.workspace_id,     triples=formatted_triples,     name=\"\" ) <p>Build and run a structured query using the inferred graph schema.</p> In\u00a0[\u00a0]: Copied! <pre>schema_id = whyhow_client.graphs.get(graph_id=graph.graph_id).schema_id\n\nschema = whyhow_client.schemas.get(schema_id)\n\nentities = [entity.name for entity in schema.entities]\nrelations = [relation.name for relation in schema.relations]\n\n\nprint(entities)\nprint(relations)\n\nquery = \"What lawsuits is Amazon dealing with?\"\n\n# Using the entities and relations from the schema, you we will use an LLM to extract relevant entities and relations from a question and make a structured query, helping guarantee completeness\nprompt = f\"\"\"\n    Perform entity and relation extraction on the question below using the list of entity types and relation types provided.\n    The output should an object with three arrays: \"entity_types\" which are the entity types detected in the question, \"relation_types\" which are the relation types detected in the question, and \"values\" which are the relevant entity names detected in the question.\n\n    The output should look like this:\n\n    {{\"entity_types\": [\"Person\", \"Place\"], \"relation_types\": [\"LIVES_IN], \"values\": [\"John Doe\", \"New York\"]}}\n\n    Do not include supporting information. Do not wrap the response in JSON markers. If there is no relevant information, just return an empty array.\n    Question:{query}\n    Entities:{entities}\n    Relations:{relations}\n\"\"\"\nresponse = openai_client.chat.completions.create(\n    model=\"gpt-4o\",\n    messages=[\n        {\"role\": \"user\", \"content\": prompt},\n    ],\n    max_tokens=4000,\n    temperature=0.1\n)\n\nstructured_query = json.loads(response.choices[0].message.content)\n\nstructured_query_response = whyhow_client.graphs.query_structured(\n    entities=structured_query[\"entity_types\"], \n    relations=structured_query[\"relation_types\"], \n    values=structured_query[\"values\"], \n    graph_id=graph.graph_id)\n\nprint(structured_query_response)\n</pre> schema_id = whyhow_client.graphs.get(graph_id=graph.graph_id).schema_id  schema = whyhow_client.schemas.get(schema_id)  entities = [entity.name for entity in schema.entities] relations = [relation.name for relation in schema.relations]   print(entities) print(relations)  query = \"What lawsuits is Amazon dealing with?\"  # Using the entities and relations from the schema, you we will use an LLM to extract relevant entities and relations from a question and make a structured query, helping guarantee completeness prompt = f\"\"\"     Perform entity and relation extraction on the question below using the list of entity types and relation types provided.     The output should an object with three arrays: \"entity_types\" which are the entity types detected in the question, \"relation_types\" which are the relation types detected in the question, and \"values\" which are the relevant entity names detected in the question.      The output should look like this:      {{\"entity_types\": [\"Person\", \"Place\"], \"relation_types\": [\"LIVES_IN], \"values\": [\"John Doe\", \"New York\"]}}      Do not include supporting information. Do not wrap the response in JSON markers. If there is no relevant information, just return an empty array.     Question:{query}     Entities:{entities}     Relations:{relations} \"\"\" response = openai_client.chat.completions.create(     model=\"gpt-4o\",     messages=[         {\"role\": \"user\", \"content\": prompt},     ],     max_tokens=4000,     temperature=0.1 )  structured_query = json.loads(response.choices[0].message.content)  structured_query_response = whyhow_client.graphs.query_structured(     entities=structured_query[\"entity_types\"],      relations=structured_query[\"relation_types\"],      values=structured_query[\"values\"],      graph_id=graph.graph_id)  print(structured_query_response)  <p>Run an unstructured query</p> In\u00a0[\u00a0]: Copied! <pre>unstructured_query_response = whyhow_client.graphs.query_unstructured(query=query, graph_id=graph.graph_id)\n\nprint(unstructured_query_response)\n</pre> unstructured_query_response = whyhow_client.graphs.query_unstructured(query=query, graph_id=graph.graph_id)  print(unstructured_query_response) <p>Generate a final response by combining the results of the structured and unstructured queries.</p> In\u00a0[\u00a0]: Copied! <pre>prompt = f\"\"\"\n    Using the supporting information from the natural language response and the structured triples below, provide a detailed answer to the question below:\n\n    Question: {query}\n    Natural Language Response: {unstructured_query_response.answer}\n    Structured Triples: {structured_query_response}\n\"\"\"\nanswer = openai_client.chat.completions.create(\n    model=\"gpt-4o\",\n    messages=[\n        {\"role\": \"user\", \"content\": prompt},\n    ],\n    max_tokens=4000,\n    temperature=0.1\n)\n\nprint(answer.choices[0].message.content)\n</pre> prompt = f\"\"\"     Using the supporting information from the natural language response and the structured triples below, provide a detailed answer to the question below:      Question: {query}     Natural Language Response: {unstructured_query_response.answer}     Structured Triples: {structured_query_response} \"\"\" answer = openai_client.chat.completions.create(     model=\"gpt-4o\",     messages=[         {\"role\": \"user\", \"content\": prompt},     ],     max_tokens=4000,     temperature=0.1 )  print(answer.choices[0].message.content)"},{"location":"examples/query_completeness/#import-configure-dependencies","title":"Import &amp; configure dependencies\u00b6","text":""},{"location":"examples/query_completeness/#10k-documents","title":"10k Documents\u00b6","text":"<p>In this example, we're going to leverage 10k documents from Amazon and Walmart for the past 5 years. Specifically, we're going to use the legal proceedings reported by each of these companies. You can find these documents on the SEC website or on the Investor Relations page of each company.</p>"},{"location":"examples/query_completeness/#vector-database-retrieval","title":"Vector database retrieval\u00b6","text":""},{"location":"examples/query_completeness/#upsert-to-pinecone","title":"Upsert to Pinecone\u00b6","text":"<p>Prepare and upsert documents to Pinecone so we can test vector search.</p>"},{"location":"examples/query_completeness/#query-pinecone","title":"Query Pinecone\u00b6","text":""},{"location":"examples/query_completeness/#generate-response-from-retrieved-chunks","title":"Generate response from retrieved chunks\u00b6","text":""},{"location":"examples/query_completeness/#graph-retrieval","title":"Graph Retrieval\u00b6","text":""},{"location":"examples/query_completeness/#extract-triples-using-custom-prompt","title":"Extract triples using custom prompt\u00b6","text":"<p>Simple script to extract triples using a custom prompt which we will use to instruct the LLM to build precise triples for our use case.</p>"},{"location":"examples/query_completeness/#parse-10k-documents","title":"Parse 10k Documents\u00b6","text":"<p>Using llm sherpa, we will parse the 10k documents and extract the most relevant information for our use case. This will ensure we're pulling meaningful data about legal proceedings from both Walmart and Amazon's 10k filings</p>"},{"location":"examples/query_completeness/#format-triples","title":"Format triples\u00b6","text":"<p>Transform the triples into Whyhow format.</p>"},{"location":"examples/query_completeness/#build-graph","title":"Build Graph\u00b6","text":"<p>Using the structured Triples, create a graph using the Whyhow SDK.</p>"},{"location":"examples/query_completeness/#query-graph","title":"Query graph\u00b6","text":"<p>Run a hybrid search using the structured and unstructured query methods and combine the responses to generate a response.</p>"},{"location":"examples/update_existing_graph/","title":"Building Harry Potter and the Chamber of Secrets","text":"<p>Install required pip packages</p> <pre>pip install pypdf tqdm pymongo\n</pre> In\u00a0[\u00a0]: Copied! <pre>import os \n\nfrom pypdf import PdfReader\nfrom tqdm import tqdm\nfrom bson import ObjectId\n\nfrom whyhow import WhyHow\nfrom whyhow.schemas import SchemaEntity, SchemaRelation, SchemaTriplePattern, Chunk\n</pre> import os   from pypdf import PdfReader from tqdm import tqdm from bson import ObjectId  from whyhow import WhyHow from whyhow.schemas import SchemaEntity, SchemaRelation, SchemaTriplePattern, Chunk In\u00a0[\u00a0]: Copied! <pre>client = WhyHow(api_key=os.environ[\"WHYHOW_API_KEY\"], base_url=os.environ[\"WHYHOW_BASE_URL\"])\n</pre> client = WhyHow(api_key=os.environ[\"WHYHOW_API_KEY\"], base_url=os.environ[\"WHYHOW_BASE_URL\"]) In\u00a0[\u00a0]: Copied! <pre>workspace = client.workspaces.create(name=\"Harry Potter Workspace\")\n</pre> workspace = client.workspaces.create(name=\"Harry Potter Workspace\") In\u00a0[\u00a0]: Copied! <pre>entities = [\n    SchemaEntity(\n        name=\"character\",\n        description=\"A person appearing in the book, e.g., Harry Potter, Ron Weasley, Hermione Granger, Albus Dumbledore.\",\n        fields=[]\n    ),\n    SchemaEntity(\n        name=\"object\",\n        description=\"Inanimate items that characters use or interact with, e.g., wand, Philosopher's Stone, Invisibility Cloak, broomstick.\",\n        fields=[]\n    )\n]\n\nrelations = [\n    SchemaRelation(\n        name=\"friends with\",\n        description=\"Denotes a friendly relationship between characters.\",\n    ),\n    SchemaRelation(\n        name=\"interacts with\",\n        description=\"Describes a scenario in which a character engages with another character, creature, or object.\",\n    )\n]\n\nschema = client.schemas.create(\n    name=\"Harry Potter Schema\",\n    workspace_id=workspace.workspace_id,\n    entities=entities,\n    relations=relations,\n    patterns=[\n        SchemaTriplePattern(\n            head=entities[0],\n            relation=relations[0],\n            tail=entities[0],\n            description=\"One character is friends with another, e.g., Harry Potter is friends with Ron Weasley.\"\n        ),\n        SchemaTriplePattern(\n            head=entities[0],\n            relation=relations[1],\n            tail=entities[1],\n            description=\"A character interacting with an object, e.g., Harry Potter interacts with the Invisibility Cloak.\"\n        )\n    ]\n)\n</pre> entities = [     SchemaEntity(         name=\"character\",         description=\"A person appearing in the book, e.g., Harry Potter, Ron Weasley, Hermione Granger, Albus Dumbledore.\",         fields=[]     ),     SchemaEntity(         name=\"object\",         description=\"Inanimate items that characters use or interact with, e.g., wand, Philosopher's Stone, Invisibility Cloak, broomstick.\",         fields=[]     ) ]  relations = [     SchemaRelation(         name=\"friends with\",         description=\"Denotes a friendly relationship between characters.\",     ),     SchemaRelation(         name=\"interacts with\",         description=\"Describes a scenario in which a character engages with another character, creature, or object.\",     ) ]  schema = client.schemas.create(     name=\"Harry Potter Schema\",     workspace_id=workspace.workspace_id,     entities=entities,     relations=relations,     patterns=[         SchemaTriplePattern(             head=entities[0],             relation=relations[0],             tail=entities[0],             description=\"One character is friends with another, e.g., Harry Potter is friends with Ron Weasley.\"         ),         SchemaTriplePattern(             head=entities[0],             relation=relations[1],             tail=entities[1],             description=\"A character interacting with an object, e.g., Harry Potter interacts with the Invisibility Cloak.\"         )     ] ) In\u00a0[\u00a0]: Copied! <pre># Create graph from schema and documents\ngraph = client.graphs.create(\n    workspace_id=workspace.workspace_id,\n    schema_id=schema.schema_id,\n    name=\"Harry Potter Graph\",\n    document_ids=[str(ObjectId())]\n)\n# Creating your graph\n</pre> # Create graph from schema and documents graph = client.graphs.create(     workspace_id=workspace.workspace_id,     schema_id=schema.schema_id,     name=\"Harry Potter Graph\",     document_ids=[str(ObjectId())] ) # Creating your graph In\u00a0[\u00a0]: Copied! <pre># Run with Harry Potter and the Chamber of Secrets\nreader = PdfReader(\"documents/Harry_Potter_and_the_Chamber_of_Secrets.pdf\")\n</pre> # Run with Harry Potter and the Chamber of Secrets reader = PdfReader(\"documents/Harry_Potter_and_the_Chamber_of_Secrets.pdf\") In\u00a0[\u00a0]: Copied! <pre>page_splitter = \" \\n       \"\ntext = page_splitter.join([page.extract_text() for page in reader.pages])\n</pre> page_splitter = \" \\n       \" text = page_splitter.join([page.extract_text() for page in reader.pages]) In\u00a0[\u00a0]: Copied! <pre>for i in tqdm(range(0, len(text), 1024)):\n    chunk = text[i:i + 1024]\n    chunks = client.chunks.create(\n        workspace_id=workspace.workspace_id,\n        chunks=[\n            Chunk(\n                content=chunk\n            )\n        ]\n    )\n    client.graphs.add_chunks(\n        graph_id=graph.graph_id,\n        ids=[chunks[0].chunk_id]\n    )\n</pre> for i in tqdm(range(0, len(text), 1024)):     chunk = text[i:i + 1024]     chunks = client.chunks.create(         workspace_id=workspace.workspace_id,         chunks=[             Chunk(                 content=chunk             )         ]     )     client.graphs.add_chunks(         graph_id=graph.graph_id,         ids=[chunks[0].chunk_id]     ) In\u00a0[\u00a0]: Copied! <pre># Query graph created from schema\nquestion = \"Who is Harry friends with?\"\nquery = client.graphs.query_unstructured(\n    graph_id=graph.graph_id,\n    query=question,\n)\nprint(\"Query Response:\", query.answer)\n</pre> # Query graph created from schema question = \"Who is Harry friends with?\" query = client.graphs.query_unstructured(     graph_id=graph.graph_id,     query=question, ) print(\"Query Response:\", query.answer) In\u00a0[\u00a0]: Copied! <pre># Query graph created from schema\nquestion = \"Who is Harry friends with?\"\nquery = client.graphs.query_unstructured(\n    graph_id=graph.graph_id,\n    query=question,\n    include_chunks=True\n)\nprint(\"Query Response:\", query.answer)\n</pre> # Query graph created from schema question = \"Who is Harry friends with?\" query = client.graphs.query_unstructured(     graph_id=graph.graph_id,     query=question,     include_chunks=True ) print(\"Query Response:\", query.answer) In\u00a0[\u00a0]: Copied! <pre>query = client.graphs.query_structured(\n    graph_id=graph.graph_id,\n    relations=[\"friends with\"],\n)\nprint(\"Query Response:\")\nfor triple in query.triples:\n    print(f\"{triple.head.name} {triple.relation.name} {triple.tail.name}\")\n</pre> query = client.graphs.query_structured(     graph_id=graph.graph_id,     relations=[\"friends with\"], ) print(\"Query Response:\") for triple in query.triples:     print(f\"{triple.head.name} {triple.relation.name} {triple.tail.name}\")"},{"location":"examples/update_existing_graph/#building-harry-potter-and-the-chamber-of-secrets","title":"Building Harry Potter and the Chamber of Secrets\u00b6","text":"<p>In this notebook, we'll gradually construct Harry Potter and the Chamber of Secrets by going through the text and adding it chunk by chunk.</p>"},{"location":"examples/update_existing_graph/#create-schema-from-scratch","title":"Create Schema from scratch\u00b6","text":""},{"location":"examples/update_existing_graph/#create-graph","title":"Create Graph\u00b6","text":""},{"location":"examples/update_existing_graph/#process-documents","title":"Process Documents\u00b6","text":""},{"location":"examples/update_existing_graph/#query-graph","title":"Query Graph\u00b6","text":""}]}